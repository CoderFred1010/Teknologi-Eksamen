1. Grundbegreber

Dockerfile: opskrift

Image: bygget artefakt

Container: kÃ¸rende instans af et image

ğŸ‘‰ En container er ikke en VM:

deler kernel

er lettere og hurtigere

2. Min Dockerfile â€“ overblik

Jeg bruger multi-stage build:

Build stage

Runtime stage

FormÃ¥l:

adskille build og runtime

mindre og mere sikkert image

3. Build stage (Maven)
FROM maven:3.9.11-eclipse-temurin-21 AS build


Maven + JDK 21

bygger .jar-filen

RUN mvn clean package -DskipTests


ğŸ‘‰ Tests kÃ¸rer i CI, ikke i Docker build.

4. Runtime stage
FROM eclipse-temurin:21-jre-alpine


Kun JRE

Meget mindre image

COPY --from=build /app/target/*.jar app.jar


ğŸ‘‰ Kun det fÃ¦rdige artefakt med.

5. ENTRYPOINT
ENTRYPOINT ["java", "-jar", "app.jar"]


Det betyder:

containeren starter altid med den kommando

svarer til: â€œdet her er applikationenâ€

6. Build og run

Jeg bygger:

docker build -t teknologi-eksamen .


Jeg kÃ¸rer:

docker run -p 8080:8080 teknologi-eksamen


-p mapper host â†’ container

applikationen svarer pÃ¥ HTTP

Jeg bekrÃ¦ftede det via:

Whitelabel Error Page i browseren

7. FejlsÃ¸gning (meget vigtigt)

Jeg havde en fejl:

Spring Boot kunne ikke starte pga. datasource

LÃ¸sning:

embedded H2-database

korrekt runtime-konfiguration

fjernede WebFlux/WebMVC-konflikt

ğŸ‘‰ Det viser, at jeg kan:

debugge Docker + Java

forstÃ¥ forskel pÃ¥ build- og runtime-fejl

8. Docker og sikkerhed

Ports Ã¥bnes eksplicit

Kun nÃ¸dvendige services kÃ¸rer

Runtime-image er minimalt

9. Opsummering (emne 2)

Jeg kan forklare Dockerfile â†’ image â†’ container

Jeg bruger multi-stage builds

Jeg kan bygge og kÃ¸re images

Jeg kan fejlsÃ¸ge reelle problemer

Jeg har et image klar til deployment